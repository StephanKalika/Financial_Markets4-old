---
title: "Финансовые данные -- получение, особенности и трансформация.<br> Количественные финансы"
author: "Салихов Марсель (marcel.salikhov@gmail.com)"
date: "`r Sys.Date()`"
output:
  slidy_presentation:
    css: styles.css
    footer: НИУ ВШЭ. Салихов Марсель (marcel.salikhov@gmail.com)
    lib_dir: libs
    self_contained: no
    mathjax: local
---
   
## Цели лекции 
   
+ понять, в чем отличия **финансовых данных** от других типов данных
+ получить навыки **трансформирования** финансовых данных
+ изучить особенности расчета **доходностей**
+ как и зачем осуществляется **корректировка** на выплаты дивидендов
+ изучить основные особенности финансовых данных с точки зрения статистики
+ понять, что такое **стационарность** временных рядов и почему это важно 

## Финансовые данные 

+ Важность количественных методов в бизнесе и финансах увеличивается по мере того, как появляется большее количество информации и данных 
+ Финансовые данные систематически собираются в больших количествах и все с большей временной точностью. Достаточно большое количество финансовых данных доступно абсолютно бесплатно.  
+ По сравнению с другими областями, финансовых данных как правило достаточно много. Вопрос обычно состоит не в том, что данных нет, а в том, чтобы эффективно использовать доступные данные и получить содержательные результаты
+ В R есть множество пакетов, которые позволяют загружать финансовые данные напрямую. Вам не надо заходить куда-то в интернете, скачивать/экспортировать данные, сохранять их на свой компьютер, загружать и проч. Обычно загрузка серии - это одна строка кода. 
+ Основой пакет, который мы будем использовать для получения зарубежных финансовых данных -- `quantmod`, для российских данных -- `rusquant`.
+ Источники бесплатных данных по финансовым рынкам -- Yahoo Finance, Google Finance, FRED, Oanda. Для России - Финам, Банк России, Московская Биржа. 

## Получение финансовых данных с помощью quntmod и rusquant

```{r setup, cache=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
library("RColorBrewer")    # brewer.pal
library("e1071")           # kurtosis
library("knitr")           # opts_chunk
library(rusquant)

# utility functions
source("http://ptrckprry.com/course/forecasting/code/ad.test.R")

options(width = 80)

# color palette
palette(brewer.pal(6, "Set1"))

opts_chunk$set(fig.width=14, fig.height=7, fig.align="center", echo=FALSE, tidy=FALSE)
opts_chunk$set(cache=TRUE, fig.align="center", comment=NA, echo=FALSE, tidy=FALSE)

# преобразовать объект xts в dataframe с сохранением индекса даты
XtstoDf <- function(ts, ...){ 
  df <- as.data.frame(ts)
  df$date <- time(ts)
  return(df)
}
# encapsulate the plotting commands into a function so that we don't have to repeat ourselves
fancy.plot <- function(x, y, hguide=0, vguide=0, type = "p", col = "black", pch = 1, cex = 1, ...) {
    # set up plot region
    plot(x, y, type="n", axes=FALSE, ...)
    
    # add axes
    Axis(x, side=1, lwd=0, lwd.ticks=1, labels=TRUE)
    Axis(y, side=2, lwd=0, lwd.ticks=1, labels=TRUE)
    Axis(x, side=3, lwd=0, lwd.ticks=1, labels=FALSE)
    Axis(y, side=4, lwd=0, lwd.ticks=1, labels=FALSE)
    
    # add horizontal guide lines
    usr <- par("usr")
    if (hguide > 0) {
        abline(h=seq(usr[3], usr[4], length.out=hguide+2)[-c(1,hguide+2)], col="gray")
    }
    if (vguide > 0) {
        abline(v=seq(usr[1], usr[2], length.out=vguide+2)[-c(1,vguide+2)], col="gray")
    }

    # add the data
    if (type == "l") {
        lines(x, y, col=col)
    } else if (type == "p") {
        points(x, y, cex=cex, pch=pch, col=col)
    }
    
    # add frame
    box()
}

#getSymbols("^GSPC",src="yahoo", from ='1950-01-01') # from yahoo finance 
#write.csv(XtstoDf(GSPC), 'data/sp500.csv', row.names = FALSE)
load('../.RData')
sp500 <- read.csv('data/sp500.csv')
tail(sp500)

```


```{r, echo=TRUE, eval=FALSE}
library(quantmod)
getSymbols("^GSPC",src="yahoo", from ='1950-01-01') #  yahoo finance 
#library(devtools)
#install_github('quantviews/rusquant')
library(rusquant)
micex <- rusquant::getSymbols.Finam('MICEX', symbol.lookup = FALSE) # индекс ММВБ 

```

+ Обычно у каждой серии есть свой уникальный идентификатор (id) -- тикер -- это текстовый код - аббревиатура. Но в разных источниках могут использоваться разные тикеры для одной и той же серии. Поэтому проверяйте тикеры, чтобы удостовериться, что источники возвращает вам те данные, что вам нужны. 
К примеру, индекс S&P 500 имеет тикер `SPX` в Bloomberg, `^GSPC` -- в Yahoo Finance, `INDEXSP:.INX` -- в Google Finance, `SP500` -- во FRED.  


## Индекс S&P 500 -- долгосрочная динамика фондового рынка


```{r}
# download the data and extract the relevant columns
data <- sp500[,c('GSPC.Adjusted', 'date')]
data$date <- as.Date(data$date)
#spx <- data$GSPC.Adjusted
```


```{r, warning=FALSE, message=FALSE}
# Set up the plot axes, but don't actually plot the data (type = "n")

library(plotly)
plot_ly(data = data, x= ~date) %>%
   add_lines(y = ~GSPC.Adjusted)

```

## График OHLC

Часто визуальное предоставление финансовых серий осуществляется с помощью графиков OHLC (Open - High - Low - Close)

```{r,warning=FALSE, message=FALSE}

candleChart(GSPC['2016::'], theme = 'white', name = 'Индекс S&P500 в 2016 году')
tail(GSPC)

```


+ `Open` -- цена открытия (начало торгового дня)
+ `High` -- максимальная цена за период 
+ `Low` -- минимальная цена за период  
+ `Close` -- цена закрытия 
+ `Volume` -- цена закрытия 
+ `Adjusted` -- цена закрытия с учетом корректировок на выплату дивидендов и разделение акций 

## Вариант графика OHLC -- bar chart

```{r,warning=FALSE, message=FALSE}

barChart(GSPC['2016::'], theme = 'white', name = 'Индекс S&P500 в 2016 году (bar chart)')


```

## Внутридневные данные

+ Для дневных серий обычно используют цены закрытия торгового дня (close price). Обратите внимание, что время закрытия для разных торговых площадок может отличаться. Пример -- оценка корреляции между ценой на нефть WTI на NYMEX (время закрытия -- 21-30 по МСК) и курсом RUB/USD (фиксинг - 12-00 МСК, время основной сессии на Московской Бирже -- c 10-00 до 15-15 и так далее). Эти различия имеют значение на современных рынках. 
+ Финансовые данные зачастую доступны с очень высоким разрешением -- вплоть до мониторинга данных по каждым отдельным торговым операциям (tick data)
+ Многие современные финансовые рынки функционируют в круглосуточном режиме. К примеру, валютные рынки устроены подобным образом. 
+ Скорость обработки информации за последние 10-15 лет выросла драматическим образом. Поэтому реакция рынки на те или иные события очень быстро. Использование дневных данных не позволяет оценивать эти эффекты. 
+ Как правило, у вас нет ограничений использовать только дневные данные, внутридневные данные доступны в специализированных системах и базах данных, иногда -- бесплатно.  
+ Внутридневные данные занимают много места и требуют много вычислительных ресурсов для обработки

## Торговля RUB/USD на прошлой неделе - данные за каждые 15 минут 

```{r, warning=FALSE, echo=TRUE}
start.date <- as.Date('2016-11-14')
#rub <- rusquant::getSymbols.Finam('USDRUB', from=start.date, symbol.lookup = FALSE, period = "15min") # RUB/USD
candleChart(rub, theme='white', name = 'Динамика торгов долларом США на прошлой неделе')

```



## Логарифм S&P500

Используйте лог-преобразование для того, чтобы скорректировать серию на экспоненциальный рост и "ограничить" волатильность 

```{r, warning=FALSE, message=FALSE}

library(plotly)
#plot_ly(data = XtstoDf(GSPC), x= ~date) %>%
#   add_lines(y = ~log(GSPC.Adjusted))

fancy.plot(index(GSPC),GSPC$GSPC.Adjusted, t="l", xlab="Дата", ylab="Исходный уровень", col=2)


```

```{r}
fancy.plot(index(GSPC),log(GSPC$GSPC.Adjusted), t="l", xlab="Дата", ylab="Лог", col=2)
```


## Регрессия логарифма S&P по времени

```{r, echo=TRUE}
names(data)[1] <- 'sp500'
data$sp500.log <- log(data$sp500)
time <- 1:nrow(data)
model.time <- lm(data$sp500.log ~ time)
summary(model.time)
```

Сравним фактические данные и модельную регрессию: 

```{r, echo=FALSE}
fancy.plot(time, data$sp500.log, type="l", col=2, ylab="Log(S&P 500)", hguide=3, xlab = 'Время (дни)')
abline(model.time, col=1, lty=2)

```

## Может ли вчерашнее значение индекса предсказать нам значение сегодня?

```{r}
data$sp500.lag.log <- c(NA, lag(data$sp500.log)[-nrow(data)])
fancy.plot(data$sp500.lag.log, data$sp500.log, cex=0.5, col=2, xlab="Значение вчера Log(S&P 500)", ylab="Значение сегодня Log(Dow)", asp=1)

```

```{r, echo=TRUE}
model.yest <- lm(data = data, sp500.log ~ sp500.lag.log)
print(summary(model.yest), digits=6)
confint(model.yest)
```

Похоже, что не очень. Согласно посчитанной регрессии, "сегодня" будет таким же, как вчера ($\beta = 1$).

Наблюдение -- для финансовых данных обычно наблюдения, которые находятся "рядом"" другом с другом, **скоррелированны между собой**. 

## Гистограмма лог значений S&P 500

Гистограмма  указывает на то, что моменты распределения не являются устойчивыми. Использование данных в такой форме ("в уровнях") не очень осмысленно.

```{r}
hist(data$sp500.log, breaks=50, col=2, xlab="Log(S&P 500)", main="Гистограмма лог-значений S&P 500")
```

Может быть, надо преобразовать значения серии?

## Доходность 

Доходность -- лог-значение "сегодня" минус лог-значение "вчера"

```{r}
data$sp500.ret <- data$sp500.log - data$sp500.lag.log
fancy.plot(data$date, data$sp500.ret, t="l", xlab="Дата", ylab="Лог-доходность", col=2)

```

## Нетто-доходность

Пусть $P_t$ это цена финансового актива в момент времени $t$. Если мы предположим, что в этот период не было выплат дивидендов, то **нетто-доходность** за период владения со времени $t-1$ до времени $t$ составит

$$ R_t = \frac{P_t}{P_{t-1}} -1 = \frac{P_t - P_{t-1}}{P_{t-1}} $$

Числитель -- прибыль, полученная за период владения, отрицательное значение означает убыток. 

Знаменатель -- первоначальная инвестиция, сделанная в начале периода владения
Минимальное значение доходности = -1, то есть 100% убыток или потеря всей первоначальной инвестиции. 

$$ R_t \geq -1 $$

## Валовая доходность

Валовая доходность определяется как:

$$ \frac{P_t}{P_{t-1}} = 1 + R_t $$

Доходности не зависят от размерности исходных величин (доллары, рубли и проч.)
Размерность доходности -- время. Она зависит от единиц $t$ (час, день, неделя, год). 

Валовая доходность за последние $k$ периодов является произведением доходность за каждый из периодов: 

$$ 1 + R_t(k) = \frac{P_t}{P_{t-k}}  = (\,\frac{P_t}{P_{t-1}})\,(\frac{P_{t-1}}{P_{t-2}}) ... (\frac{P_{t-k+1}}{P_{t-k}}) $$

## Лог-доходность (continuously compounded return)

Лог-доходность или `continuously compounded returns`  определяются как: 

$$ r_t = log(1 + R_t) = log(\frac{P_t}{P_{t-1}}) = p_t - p_{t-1} $$

где $p_t = log(P_t)$ -- лог-цена. 

Лог-доходности примерно равно доходностям из-за того, что если $x$ достаточно малая величина, то $log(1+x) \approx x$

```{r}
retseq <- seq(-.5, .5, length=100)
 plot(retseq, log(retseq + 1), type="l",
      axes=FALSE, col="blue", lwd=3, xlab="простая доходность", ylab="Лог доходность")
 axis(1, at=c(-.5,-0.25, 0, 0.25, .5), label=c("-50%", "-25%", "0%", "25%", "50%"))
 axis(2, at=c(-.5,-0.25, 0, 0.25, .5), label=c("-50%", "-25%", "0%", "25%", "50%"))
 abline(0,1, lty=2, lwd = 2, col="red")
```


+ Чем более короткий промежуток времени (дни, часы, минуты) мы используем, тем меньше будет доходность меньше по абсолютным значениям.Поэтому мы можем ожидать, что доходности будут примерно равно лог-доходностям для дневных и внутридневных данных. Для годовых данных, к примеру, ошибка будет гораздо больше -- для них не стоит использовать такое преобразование
+ Доходности и лог-доходности имеют одинаковый знак 
+ Лог-доходности на всех промежутках значениях больше простой доходности. По мере приближения обычной доходности к -1 (потеря всех инвестиций), лог-доходность стремится к $-\infty$

## Корректировка на дивиденды для акций 

+ Многие компании, особенно из традиционных секторов, платят дивиденды, которые должны быть учтены при оценке **полной  доходности (total return series)**.  
+ Если мы не учитываем эту компоненты, то мы рискуем неправильно оценивать доходности для инвесторов и исказить результаты анализа. 
+ Иногда компании проводят разделение акций (stock split), то есть обмен "старых" акций на "новые" в определенном соотношении. К примеру, каждый владелец 1 старой акции получает 2 новых. В этих операциях нет экономической сути, они делаются просто для удобства котирования цен и/или по историческим причинам.  


## Акции Exxon Mobil - 1

```{r}
chart_Series(XOM$XOM.Close, name = 'Цена акций Exxon Mobil (без корректировки на дивиденды и разделения акций)',multi.col = TRUE)
```

## Акции Exxon Mobil - 2

```{r}
chart_Series(XOM$XOM.Adjusted, name = 'Цена акций Exxon Mobil (после корректировки на дивиденды и разделение)')
```

## Порядок корректировки цены акции на дивиденды

+ Если дивиденды выплачиваются до период времени $t$, то валовая доходность определяется в момент времени $t$ определяется как 

$$ 1+ R_t = \frac{P_t + D_t}{P_{t-1}} = \frac{P_t}{P_{t-1}} + \frac{D_t}{P_{t-1}} $$ 


Нетто-доходность будет $r_t = log(1+R_t) = log(P_t + D_t) - log(P_{t-1})$.

+ Для дневных доходностей, дивидендная доходность равно нулю во все дни, когда не выплачиваются дивиденды. 
Для компаний, которые не выплачивают дивиденды, полная доходность и ценовая доходность равны друг другу. 
+ Для дивидендов стоимость дивидендов вычитается из цены закрытия на дату "отсечки". Дата "отсечки" -- последняя дата, на которую признается право акционера на получение дивидендов. 
+ Предположим, что цена закрытия акций Роснефти составила 300 рублей в четверг. После закрытия торгов, Роснефть объявила о том, что выплатит дивиденды в размере на 10 рублей на акцию. Тогда скорректированная цена акции составит 290 рублей = 300 - 10. 
+ Корректировка на дивиденды "меняет"" цены в прошлом. Текущая скорректированная цена и текущая цена на рынке должны быть равны другу другу. Поэтому корректируются именно исторические данные, а не текущие. 


## Полная доходность (total return) для акций Газпрома

+ Для многих российских бумаг, разница между полной доходностью и ценовой доходностью так же важна
+ В Bloomberg можно оценивать total return для российских бумаг 

<div align="center">
  <img src="fig/GAZP_total_return.png" width="945" height="474" />
</div>

К сожалению, доступные бесплатные источники не предоставляют информацию по полной доходности для российских активов. 
Bloomberg предоставляет данные по дивидендам и total return для российских бумаг. 

## Сравнение доходностей нескольких бумаг за период времени 

нарисуем график трех бумаг -- Amazon, Google и Facebook. 
Акции Facbook торгуются с мая 2012 года (IPO). Поэтому график начинается с 18 мая 2012 года. 

```{r}
plot.xts(tech_stocks,legend.loc = 'top', main = 'Динамика цен на акций интернет-компаний')

```

нормируем график по состоянию на 18 мая 2012 года -- поделим значения каждой бумага на соответствующее значение в этот день

```{r, echo=TRUE}
library(xts)
tech_stocks2 <- tech_stocks
tech_stocks2[,1] <- tech_stocks2[,1] / as.numeric(coredata(tech_stocks[1,1]))
tech_stocks2[,2] <- tech_stocks2[,2] / as.numeric(coredata(tech_stocks[1,2]))
tech_stocks2[,3] <- tech_stocks2[,3] / as.numeric(coredata(tech_stocks[1,3]))

plot.xts(tech_stocks2,legend.loc = 'top', main = 'Нормированная динамика цен на акций интернет-компаний')

```


## Позволяет доходность вчера предсказать доходность сегодня?

```{r}
data$sp500.ret.lag <- c(NA, data$sp500.ret[-nrow(data)])
fancy.plot (data$sp500.ret.lag, data$sp500.ret, col=2, cex=0.5, xlab="Доходность вчера", ylab="Доходность сегодня", asp=1)

```

посчитаем регрессию для доходностей

```{r}
model.ret <- lm(data = data, sp500.ret ~ sp500.ret.lag)
summary(model.ret, digits = 4)
```


## Гистограмма доходностей 

```{r,r, warning=FALSE}
hist(data$sp500.ret, breaks=100, col=2, xlab="Доходность", main="")
```

Доходности возвращаются к среднему значению (mean reversion)

```{r, warning=FALSE}
library(ggplot2)
ggplot(tail(data,1000), aes(x=sp500.ret)) + 
   geom_histogram( aes(y=..density..),
                   colour="black", 
                   fill="white") +
   stat_function(fun=dnorm, args=list(mean=mean(data$sp500.ret, na.rm=TRUE), sd=sd(data$sp500.ret, na.rm=TRUE)), col = 'red')+theme_minimal()
```


## Эксцесс и нормальность доходностей

Эксцесс (kurtosis) -- мера остроты пика распределения случайной величины. 
 
```{r, echo =TRUE}
kurtosis(data$sp500.ret, na.rm=TRUE) # избыточный эксцесс(excess kurtosis), 0  -- для нормального распределения 
ad.test(data$sp500.ret) 

```

Доходности имеют избыточный эксцесс ("тяжелые хвосты" -- **heavy tails**).

## Волатильности устойчивы во времени 

квадраты доходностей

```{r, echo=TRUE}
fancy.plot(data$date, (data$sp500.ret)^2, t="l", xlab="Date", ylab="Квадрат доходности", col=2)
mod.vol <- lm(data =data, sp500.ret^2 ~ sp500.ret.lag^2)
cor(data$sp500.ret,data$sp500.ret.lag, use = "complete.obs" )
cor(data$sp500.ret^2,data$sp500.ret.lag^2, use = "complete.obs" )
```

```{r}
fancy.plot(data$date, abs(data$sp500.ret), t="l", xlab="Date", ylab="Абсолютное значение доходности", col=2)
```

## Основные особенности финансовых серий: 

1. Многие финансовые серии растут экспоненциально и имеют изменяющуюся волатильность 
2. Наблюдения, которые находятся рядом, скоррелированны между собой 
3. Доходности имеют избыточный эксцесс (heavy tails)
4. Волатильность устойчива во времени (persistent) и часто в финансовых данных наблюдаются кластеры волатильности

## Понятие стационарности и почему оно важно

+ Стандартным допущением при анализе временных рядов является **стационарность**. 
+ Серия является стационарной, если параметры генерирующего процесса не меняются со временем
+ Рассмотрим две серии А и B. Параметры серии А (среднее арифметическое, стандартное отклонение) - не меняются со временем

```{r, echo=TRUE}
mu = 0
sigma = 1
T = 100
A <- rnorm(T, mu, sigma)
plot(A, type = 'l')
```

Для серии B среднее меняется со временем 

```{r, echo=TRUE}
mu = 0
sigma = 1
T = 100
B <- rep(0, 100)
t <- seq(0,T, by = 1)

for(i in 1:T){
   B[i] <- rnorm(1, 0.05*i, sigma)
}

plot(B, type = 'l')

```

## Почему не-стационарнасть опасна?

+ Многие статистические цены требуют, чтобы данные, которые тестируются, были стационарны. 

К примеру, возьмем среднее для не-стационарного ряда (серия B, сгенерированная ранее): 

```{r}
plot(B, type = 'l')
abline(h = mean(B), col = 'red')
```

+ Рассчитанное среднее значение для всех точек бессмысленно с точки зрения прогнозирования будущих значений. 
+ Устойчивость параметров во времени дает основания считать, что рассчитанные по прошлым данным параметры, будут иметь значение и в будущем. 


Проверим стационарность с помощью стандартного теста 
```{r, echo=TRUE}
library(tseries)
adf.test(A)
adf.test(B)
```


## Использованные источники: 

1. "An Introduction to Analysis of Financial Data with R" (Ruey S. Tsay)
2. "Statistics and Data Analysis for Financial Engineering" (David Ruppert & David Matteson)
3. Analyzing Financial Data and Implementing Financial Models Using R (Clifford Ang)
4. Forecasting Financial Time Series (Patrick Perry)
